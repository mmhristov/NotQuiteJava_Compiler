//generated by abstract-syntax-gen
package minillvm.ast;
import java.util.*;

public interface Instruction extends Element{
    Element getParent();
    <T> T match(Matcher<T> s);
    void match(MatcherVoid s);
    public interface Matcher<T> {
        T case_Store(Store store);
        T case_ReturnVoid(ReturnVoid returnVoid);
        T case_ReturnExpr(ReturnExpr returnExpr);
        T case_Print(Print print);
        T case_Load(Load load);
        T case_Branch(Branch branch);
        T case_Alloc(Alloc alloc);
        T case_Bitcast(Bitcast bitcast);
        T case_Call(Call call);
        T case_HaltWithError(HaltWithError haltWithError);
        T case_GetElementPtr(GetElementPtr getElementPtr);
        T case_BinaryOperation(BinaryOperation binaryOperation);
        T case_CommentInstr(CommentInstr commentInstr);
        T case_Alloca(Alloca alloca);
        T case_Jump(Jump jump);
        T case_PhiNode(PhiNode phiNode);
    }

    public interface MatcherVoid {
        void case_Store(Store store);
        void case_ReturnVoid(ReturnVoid returnVoid);
        void case_ReturnExpr(ReturnExpr returnExpr);
        void case_Print(Print print);
        void case_Load(Load load);
        void case_Branch(Branch branch);
        void case_Alloc(Alloc alloc);
        void case_Bitcast(Bitcast bitcast);
        void case_Call(Call call);
        void case_HaltWithError(HaltWithError haltWithError);
        void case_GetElementPtr(GetElementPtr getElementPtr);
        void case_BinaryOperation(BinaryOperation binaryOperation);
        void case_CommentInstr(CommentInstr commentInstr);
        void case_Alloca(Alloca alloca);
        void case_Jump(Jump jump);
        void case_PhiNode(PhiNode phiNode);
    }

    Instruction copy();
    Instruction copyWithRefs();
    /** */
    public abstract String toString();
}
