//generated by abstract-syntax-gen
package minillvm.ast;
import java.util.*;

public interface Type extends Element{
    Element getParent();
    <T> T match(Matcher<T> s);
    void match(MatcherVoid s);
    public interface Matcher<T> {
        T case_TypeVoid(TypeVoid typeVoid);
        T case_TypeBool(TypeBool typeBool);
        T case_TypeByte(TypeByte typeByte);
        T case_TypeInt(TypeInt typeInt);
        T case_TypeStruct(TypeStruct typeStruct);
        T case_TypeProc(TypeProc typeProc);
        T case_TypeArray(TypeArray typeArray);
        T case_TypePointer(TypePointer typePointer);
        T case_TypeNullpointer(TypeNullpointer typeNullpointer);
    }

    public interface MatcherVoid {
        void case_TypeVoid(TypeVoid typeVoid);
        void case_TypeBool(TypeBool typeBool);
        void case_TypeByte(TypeByte typeByte);
        void case_TypeInt(TypeInt typeInt);
        void case_TypeStruct(TypeStruct typeStruct);
        void case_TypeProc(TypeProc typeProc);
        void case_TypeArray(TypeArray typeArray);
        void case_TypePointer(TypePointer typePointer);
        void case_TypeNullpointer(TypeNullpointer typeNullpointer);
    }

    Type copy();
    Type copyWithRefs();
    /** */
    public abstract String toString();
    /** "checks, whether this type is equal to another type"*/
    public abstract boolean equalsType(Type other);
}
